create extension vector with schema extensions;

create type sender as ENUM (
  'user',
  'assistant'
);

create table documents_embeddings (
  id uuid primary key default gen_random_uuid(),
  embedding vector (1536),
  content text not null,
  metadata jsonb default '{}' not null,
  created_at timestamptz default now() not null
);

grant delete on table documents_embeddings to authenticated;
grant select, delete, insert, update on table documents_embeddings to service_role;

alter table documents_embeddings enable row level security;

create policy documents_read
  on documents_embeddings
  for select
  to authenticated
  using (
    (metadata ->> 'account_id')::uuid = auth.uid()
  );

create policy documents_delete
  on documents_embeddings
  for delete
  to authenticated
  using (
    (metadata ->> 'account_id')::uuid = auth.uid()
  );

/*
* DOCUMENTS
*/
create table documents (
  content text not null,
  title varchar(500) not null,
  created_at timestamptz default now() not null,
  account_id uuid not null references public.accounts(id) on delete cascade,
  id uuid primary key default gen_random_uuid()
);

grant select, delete on table documents to authenticated, service_role;
grant delete, insert, update on table documents to service_role;

alter table documents enable row level security;

create policy documents_read
  on documents
  for select
  to authenticated
  using (
    account_id = auth.uid()
  );

create policy documents_delete
  on documents
  for delete
  to authenticated
  using (
    account_id = auth.uid()
  );

/*
* CONVERSATIONS
*/
create table conversations (
  id bigint generated by default as identity primary key,
  reference_id varchar(100) not null unique,
  name varchar(500) not null,
  document_id uuid not null references public.documents on delete cascade,
  account_id uuid not null references public.accounts(id) on delete cascade,
  created_at timestamptz default now() not null
);

grant select, delete, insert, update on table documents to authenticated, service_role;

alter table conversations enable row level security;

create policy conversations_insert
  on conversations
  for insert
  to authenticated
  with check (
    account_id = auth.uid()
  );

create policy conversations_read
  on conversations
  for select
  to authenticated
  using (
    account_id = auth.uid()
  );

create policy conversations_delete
  on conversations
  for delete
  to authenticated
  using (
    account_id = auth.uid()
  );

/*
* MESSAGES
*/
create table messages (
  id bigint generated by default as identity primary key,
  conversation_id bigint not null references public.conversations on delete cascade,
  account_id uuid not null references public.accounts on delete cascade,
  text varchar(2000) not null,
  sender sender not null,
  created_at timestamptz default now() not null
);

grant select, delete, insert, update on table messages to authenticated, service_role;

alter table messages enable row level security;

create policy messages_read
  on messages
  for select
  to authenticated
  using (
     account_id = auth.uid()
  );

create policy messages_insert
  on messages
  for insert
  to authenticated
  with check (
     account_id = auth.uid()
  );

create policy messages_delete
  on messages
  for delete
  to authenticated
  using (
    account_id = auth.uid()
  );

/*
* PLANS
*/
create table plans (
  name text not null,
  price_id text not null,
  max_documents bigint not null,
  tokens bigint not null,
  primary key (price_id)
);

grant select on table plans to authenticated, service_role;

alter table plans enable row level security;

create policy plans_read
    on plans
    for select
    to authenticated
    using (true);

/*
* CREDITS
*/
create table credits_usage (
  id bigint generated by default as identity primary key,
  account_id uuid not null references public.accounts on delete cascade,
  tokens_quota bigint default 500000 not null
);

grant select on table credits_usage to authenticated;
grant select, insert, update, delete on table credits_usage to service_role;

alter table credits_usage enable row level security;

create policy read_credits_usage
  on credits_usage
  for select
  to authenticated
  using (
    account_id = auth.uid()
  );

-- insert usage row for organizations on creation
create function public.handle_new_account_credits_usage()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.credits_usage (account_id)
  values (new.id);
  return new;
end;
$$;

-- trigger the function every time a user is created
create trigger on_account_created
  after insert on public.accounts
  for each row execute procedure public.handle_new_account_credits_usage();

insert into storage.buckets (id, name, PUBLIC)
  values ('documents', 'documents', false);

create or replace function get_remaining_tokens()
returns bigint as $$
declare
    tokens_left bigint;
begin
    select tokens_quota from credits_usage where account_id = auth.uid() into tokens_left;

    return tokens_left;
end; $$
language plpgsql;

grant execute on function get_remaining_tokens to authenticated, service_role;

create policy all_on_storage_documents on storage.objects
  for all
  to authenticated
  using (bucket_id = 'documents' and (
    auth.uid() = ((storage.foldername(name))[1]::uuid)
  ))
  with check (
    bucket_id = 'documents' and (
      auth.uid() = ((storage.foldername(name))[1]::uuid)
    )
  );

create function match_documents (
  query_embedding vector(1536),
  match_count int DEFAULT null,
  filter jsonb DEFAULT '{}'
) returns table (
  id uuid,
  content text,
  metadata jsonb,
  similarity float
)
language plpgsql
as $$
#variable_conflict use_column
begin
  return query
  select
    id,
    content,
    metadata,
    1 - (documents_embeddings.embedding <=> query_embedding) as similarity
  from documents_embeddings
  where metadata @> filter
  order by documents_embeddings.embedding <=> query_embedding
  limit match_count;
end;
$$;

grant execute on function match_documents to authenticated, service_role;

create index on documents_embeddings using hnsw (embedding vector_cosine_ops);